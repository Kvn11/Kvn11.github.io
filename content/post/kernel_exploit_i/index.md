---
title: Intro To Kernel Exploitation - CVE-2024-0193_cos
description: Learning to pop kernels thru CVE-2024-0193_cos
date: 2024-07-04 02:45:01-0700
image: https://i.pinimg.com/564x/05/2e/8d/052e8d59f511fd32a620ce1d12da0aa3.jpg
categories:
    - Kernel
    - Exploitation
tags:
    - kernel
    - programming
    - exploit
---


# Setup

Link to the original vulnerability report can be found [here](https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2024-0193_cos/metadata.json).a


## Setting up environment

To get up and running as quick as possible, setup your environment as follows:

```bash
sudo apt update
sudo apt install -y \
python3 python3-pip python3-venv \
bc binutils bison dwarves flex gcc git gnupg2 gzip libelf-dev libncurses5-dev libssl-dev make openssl dwarves perl-base rsync tar xz-utils \
libguestfs-tools \
tmux \
gdb \
qemu qemu-kvm bridge-utils
```

Then download the most recent affected [version](https://github.com/torvalds/linux/releases/tag/v6.7-rc8):

## Building

Make a default config with:

```bash
make defconfig
```

and then `nf_tables` support with:

```
CONFIG_NETFILTER=y
CONFIG_NF_TABLES=y
```

I also have a working config [here](https://github.com/kvn11) (will add soon once post is finished).

Then build the kernel with:

```bash
make -j$(nproc)
```

Then we also need to setup directories for `libguestfs` to work properly.

```bash
make modules
make modules_install
```

Then

```bash
cp arch/x86/boot/bzImage /lib/modules/6.7.0-rc8/vmlinuz
sudo chmod +r /lib/modules/6.7.0-rc8/vmlinuz
```

Then run this script:

```bash
virt-customize -a ubuntu-24.04-minimal-cloudimg-amd64.img \
       --root-password password:root \
       --ssh-inject pwn:file:/home/jp3g/.ssh/id_rsa.pub \
       --run-command 'useradd -m -s /bin/bash pwn' \
       --password pwn:password:abc123 \
       --ssh-inject root:file:/home/jp3g/.ssh/id_rsa.pub
```

This will create an unprivileged user as well as set passwords.


## GDB and QEMU

In order to connect GDB to this container, run the following command:

```bash
qemu-system-x86_64 -m 3.5G -nographic -no-reboot \
	-enable-kvm -cpu host -smp cores=2 \
	-kernel bzImage \
	-drive file=./ubuntu-24.04-minimal-cloudimg-amd64.img \
	-nic user,model=virtio-net-pci \
	-nographic \
	-append "root=/dev/sda1 rw console=ttyS0"
```

Then run gdb:

```bash
gdb
(gdb) remote target localhost:1234
```

## Getting load address

Next, we have load the symbols from `vmlinux` into gdb at the correct address.
After you have gotten a shell in qemu as root, run:

```bash
cat /proc/kallsyms | grep strncpy_from_user
```

This will give you the address of the `strncpy_from_user` function.
You can of course use any function, but this is the one I chose for my example.
You will see the address at which the function is loaded.
I know from my own testing and calculations that `strncpy_from_user` is `0x548170` bytes from the load address.
So whatever address you got from `kallsyms`, just subtract this amount from it, and you will get your load address.

# Vulnerability

## Trigger

> A use-after-free flaw was found in the netfilter subsystem of the Linux kernel. If the catchall element is garbage-collected when the pipapo set is removed, the element can be deactivated twice. This can cause a use-after-free issue on an NFT_CHAIN object or NFT_OBJECT object, allowing a local unprivileged user with CAP_NET_ADMIN capability to escalate their privileges on the system

This is the original description of the vulnerability.
Idk bout yall, but thats like alien speak to me, so lets break it down.

## nft_set_commit_update

So this is the function where the vulnerability exists.

```c
static void nft_set_commit_update(struct list_head *set_update_list)
{
	struct nft_set *set, *next;

	list_for_each_entry_safe(set, next, set_update_list, pending_update) {
		list_del_init(&set->pending_update);

		if (!set->ops->commit)
			continue;

		set->ops->commit(set);
	}
}
```

```
 * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
 * @pos:	A pointer to the type of the list entries.
 * @n:		another pointer to the same type of list entries, used for temp storage.
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
```

This is just a macro that expands into the following:

```c
	for (
        pos = list_first_entry(head, typeof(*pos), member), n = list_next_entry(pos, member);
	    &pos->member != (head);
	    pos = n, n = list_next_entry(n, member)
    )
```
So really the function becomes:

```c
{
	struct nft_set *set, *next;

    for (
        set = list_first_entry(set_update_list, typeof(*set), pending_update),
        next = list_next_entry(set, pending_update);
	    
        &set->member != (set_update_list);
	    
        set = next, next = list_next_entry(next, pending_update)
    ) {
		list_del_init(&set->pending_update);

		if (!set->ops->commit)
			continue;

		set->ops->commit(set);
	}
}
```

Anyways the point is that in this function, the `commit()` function is called.
In the fix, they added an additional condition to `continue` if `set->dead`.
`set->dead` manes that the set will be freed, and was never cleared.

## KASLR Leak

# Background Info

## SMEP/SMAP

## Netfilter

Netfilter represents a set of hooks inside the linux kernel, allowing different kernel modules to set callback functions within the kernel's networking stack.
These hooks and callbacks become the filtering and modifications that become applied to the traffic.

## NF_Tables

## User namespaces

## CAP_NET_ADMIN

This is part of something called a linux `capability`.
`Capabilities` are part of a very granular access control system that breaks down the privileges available to the superuser `root` into units that be enabled / disabled for processes.

## pipapo

# Vulnerability

# Exploitation
