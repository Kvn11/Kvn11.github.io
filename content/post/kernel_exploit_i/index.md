---
title: Intro To Kernel Exploitation
description: Learning to pop kernels thru a case study.
date: 2024-05-19 02:45:01-0700
image: https://i.pinimg.com/564x/e9/ce/78/e9ce78deaf8da0773fcf8a0d1b4938cd.jpg
categories:
    - Kernel
    - Exploitation
tags:
    - kernel
    - programming
    - exploit
---

## Vulnerability

The vulnerability to exploit today is: [CVE-2022-27666](https://nvd.nist.gov/vuln/detail/CVE-2022-27666).
I just randomly picked this one out from the [Google Recipes Notebook](https://docs.google.com/document/d/1a9uUAISBzw3ur1aLQqKc5JOQLaJYiOP5pe_B4xCT1KA/edit#heading=h.9c6s9d5wfjju).
There a few PoC's for this vulnerability online, which is good because if I get stuck at some point, I can take a look, but the goal is to develop an exploit all on my own.
The advisory says:

> A heap buffer overflow flaw was found in IPsec ESP transformation code in `net/ipv4/esp4.c` and `net/ipv6/esp6.c`.
> This flaw allows a local attacker with a normal user privilege to overwrite kernel heap objects and may cause a local privilege escalation threat.

The vuln appears in the function `int esp_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)`.
`ESP_SKB_FRAG_MAXSIZE` is defined as `(PAGE_SIZE << SKB_FRAG_PAGE_ORDER)`.

The commit that is linked in the advisory adds a fix to check whether the len of the `skb->data_len + taillen` is greater than `(PAGE_SIZE << SKB_FRAG_PAGE_ORDER)`.

`skb` is a struct representing a socket buffer, and the payload will likely reside in the data buffer within the `skb` struct.
You can find its definition in `/include/linux/skbuff.h`
The next step is to find the references to this vulnerable function, and basically trace my way up to see how to trigger it.
The next reference to it is in `esp_output` within the same file, however `esp_output` doesn't seem to be called anywhere which is a bit strange.
Also, the function is passed to `EXPORT_SYMBOL_GPL`, so it should be accessible from other modules.
This makes it somewhat difficult now, because I still haven't figure out how to trigger the vulnerability.
However, searching for `esp_output` results in finding `/Documentation/crypto/architecture.rst`, which explains how this code is used, which is a big win.
According to google:

> IPsec is a group of protocols for securing connections between devices.
> It is used to provide secure encrypted communication between two computers over an Internet Protocol network.

It basically encrypts IP packets and authenticating the source where the packets come from.
An example would be VPN's.

The IPSEC layer invokes `esp_output` which then triggers the vulnerability, so this actually becomes incredibly simple to trigger once we know how to get the IPSEC layer to invoke the `esp_output`.
This part of IPSEC is the `Encapsulating Security Payload (ESP)` which encrypts the payload.
Based on this we can assume that we don't need to setup anything external for this vulnerability, we just need to prepare an IP packet to be sent out.


## Environment Setup

### QEMU

I recommend you use an Ubuntu VM for this, I had issues developing on Kali.
We can start by setting up github.
After you download the linux repo, switch to the vulnerable version / tag with:

```
git checkout -b CVE-2022-2766 v5.16
```
This will create a branch named `CVE-2022-2766` which will contain all the content within the `v5.16` commit, which is the last vulnerable version.

We can then more or less follow the instructions [given here by kernw0lf](https://kernw0lf.github.io/posts/qemu_debug/).
Create a default config file with `make defconfig`.
Then we add a few more extra settings to help with debugging:

```
CONFIG_KCOV=y
CONFIG_DEBUG_INFO=y
CONFIG_KASAN=y
CONFIG_KASAN_INLINE=y
CONFIG_CONFIGFS_FS=y
CONFIG_SECURITYFS=y
```

Additionally, there are a few other options you have to enable, but for brevity you can access the correct config file at my repo [here](https://github.com/).

Then compile with `make -j$(nproc)`.
Next you have to download the ubuntu cloud iso.
I tried getting this to work with busybox, as I wanted a barebones system so I can focus on just this vulnerability, but after several days of struggling I gave in and opted for this method you'll see below.
First, download a recent minimal Ubuntu cloud image from [here](https://cloud-images.ubuntu.com/minimal/releases/): 

Then you need to configure the users, set up ssh keys, etc:

```bash
sudo apt-get install libguestfs-tools

virt-customize -a /path/to/ubuntu.img \
    --run-command 'apt-get update' \
    --install ssh-server \
    --install strongswan \
    --install vim \
    --run-command 'systemctl enable ssh' \
    --root-password password:root \
    --ssh-inject root:file:/path/to/root/ssh.pub \
    --run-command 'useradd -m -s /bin/bash pwn' \
    --password pwn:password:abc123 \
    --ssh-inject pwn:file:/path/to/pwn/ssh.pub \
    --copy-in /lib/modules/5.16.0:/lib/modules/
```

Then we can run the image like:

```bash
#!/bin/bash

qemu-system-x86_64 \
	-m 2G \
	-smp 2 \
	-kernel ./bzImage \
	-drive file=./ubuntu-20.10-minimal-cloudimg-amd64.img \
	-append "root=/dev/sda1 rw console=ttyS0" \
	-nographic \
	-netdev user,id=net0,hostfwd=tcp::2222-:22 \
	-device virtio-net,netdev=net0
```

After logging in, verify that `strongswan` is running with:

```bash
systemctl status strongswan-starter
```

### Networking

We also need set up IPSec's config on the guest to ensure we are creating IPSEC packets.
For this purpose I'll create a "non-working" configuration, but it should be enough for our exploit.
Add the following files:

```
# Added to /etc/ipsec.conf

conn local-to-fake
    left=<qemu ip>
    right=<host ip>
    leftsubnet=<qemu subnet>
    rightsubnet=<host subnet>
    authby=secret
    auto=start
```

```
# Added to /etc/ipsec.secrets

<qemu ip> <host ip> : PSK "secret"
```
Theres a bit more setup still, but basically you have to create a bridged network between qemu and your host, and then assign your qemu instance an IP.
I will come back later and update this section with the correct config.

### GDB

Now you can debug the `esp4` module by adding `-s -S` to the qemu command, and running gdb with:

```
gdb
(gdb) file /lib/modules/5.16.0/kernel/net/ipv4/esp4.ko
(gdb) target remote localhost:1234
(gdb) b esp_output_head
```


## Triggering

I wrote the following rust program to test `esp` functionality:

```rust
use std::net::UdpSocket;
use std::io::Result;

fn send_udp(message: &str) -> Result<()> {
    let target = "192.168.246.131:9191";
    let socket = UdpSocket::bind("0.0.0.0:1337")?;
    socket.send_to(message.as_bytes(), target);

    Ok(())
}

fn main() {
    match send_udp("Hello world!") {
        Ok(_) => println!("[+] Message sent"),
        Err(e) => eprintln!("[!] Failed to send message: {}", e),
    }
}
```

Transfer this over via `scp` or with the `--copy-in` flag from the `virt-customize` command.