---
title: Intro To Kernel Exploitation - CVE-2024-0193_cos
description: Learning to pop kernels thru CVE-2024-0193_cos
date: 2024-07-04 02:45:01-0700
image: https://i.pinimg.com/564x/05/2e/8d/052e8d59f511fd32a620ce1d12da0aa3.jpg
categories:
    - Kernel
    - Exploitation
tags:
    - kernel
    - programming
    - exploit
---


# Setup

Link to the original vulnerability report can be found [here](https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2024-0193_cos/metadata.json).


## Setting up environment

To get up and running as quick as possible, setup your environment as follows:

```bash
sudo apt update
sudo apt install -y \
python3 python3-pip python3-venv \
bc binutils bison dwarves flex gcc git gnupg2 gzip libelf-dev libncurses5-dev libssl-dev make openssl dwarves perl-base rsync tar xz-utils \
libguestfs-tools \
tmux \
gdb \
qemu qemu-kvm bridge-utils
```

Then download the google security research repo:

```bash
git clone https://github.com/google/security-research.git
```
## Getting source

Enter the security-research repo, and run:

```bash
./build_release.sh cos-105-17412.226.52 ef4d4b5eb1c59a7fd5d68a8da70462bace5ed0e7
```
to create the build that was targeted in this vulnerability.
Now inside `kernelctf/builds/cos-105-17412.226.52/` you should have a `vmlinux` file which you can use with GDB.
Additionally, the `bzImage` can be found in `arch/x86_64/boot/bzImage` inside the same build folder.
These will be used with GDB.
The config used for this build is in `lakitu_defconfig`.

- Added `CONFIG_KALLSYMS_ALL=y`

## GDB and QEMU

To boot this up for debugging, add the `-s` (enable debug mode) flag to the qemu script in the `simulator` directory:

```bash
./qemu_v3.sh "../builds/cos-105-17412.226.52/arch/x86_64/boot/" flag "/bin/bash"
```

This will log you in as root.

In order to connect GDB to this container, modify the `qemu_v*.sh` script by adding the `-s` (enable debug mode) to the qemu command:

```bash
exec qemu-system-x86_64 -m 3.5G -nographic -no-reboot \
  -monitor none \
  -enable-kvm -cpu host -smp cores=2 \
  -kernel $RELEASE_PATH/bzImage \
  -initrd ramdisk_v1.img \
  -nic user,model=virtio-net-pci \
  -drive file=rootfs_v3.img,if=virtio,cache=none,aio=native,format=raw,discard=on,readonly \
  -drive file=$FLAG_FN,if=virtio,format=raw,readonly \
  -append "console=ttyS0 root=/dev/vda1 rootfstype=ext4 rootflags=discard ro $HARDENING init=$INIT hostname=$RELEASE" \
  -s
```

```bash
gdb remote target localhost:1234
```

## Getting load address

Next, we have load the symbols from `vmlinux` into gdb at the correct address.
After you have gotten a shell in qemu as root, run:

```bash
cat /proc/kallsyms | grep strncpy_from_user
```

This will give you the address of the `strncpy_from_user` function.
You can of course use any function, but this is the one I chose for my example.
You will see the address at which the function is loaded.
Next, back in your host, run `nm vmlinux | grep strncpy_from_user` to get the address at which the function is located within the binary.
Find the difference between the two addresses, then use that value to subtract from the qemu address, and that should get you base load address.


# Background Info

## SMEP/SMAP

## Netfilter

Netfilter represents a set of hooks inside the linux kernel, allowing different kernel modules to set callback functions within the kernel's networking stack.
These hooks and callbacks become the filtering and modifications that become applied to the traffic.

## NF_Tables

## User namespaces

## CAP_NET_ADMIN

This is part of something called a linux `capability`.
`Capabilities` are part of a very granular access control system that breaks down the privileges available to the superuser `root` into units that be enabled / disabled for processes.

## pipapo

# Vulnerability

# Exploitation
